#!/bin/bash

# SuperDeploy - Unified Deployment System  
# Version: 2.1.0

# Configuration
SUPERDEPLOY_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_LIST="${SUPERDEPLOY_HOME}/build.lst"
PROJECTS_DIR="/Users/ryan/development"
DEPLOY_TEMPLATES_DIR="${SUPERDEPLOY_HOME}/deploy.d"
LOG_DIR="${SUPERDEPLOY_HOME}/logs"
LOG_FILE="${LOG_DIR}/superdeploy_$(date +%Y%m%d).log"

# Ensure required directories exist
mkdir -p "${LOG_DIR}"
mkdir -p "${DEPLOY_TEMPLATES_DIR}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "[${timestamp}] [${level}] ${message}" | tee -a "${LOG_FILE}"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check requirements
check_requirements() {
    local missing=()
    
    for cmd in terraform ansible jq; do
        if ! command_exists "$cmd"; then
            missing+=("$cmd")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        log "ERROR" "Missing required commands: ${missing[*]}"
        exit 1
    fi
}

# Load project list
load_projects() {
    if [ ! -f "${BUILD_LIST}" ]; then
        touch "${BUILD_LIST}"
    fi
    PROJECTS=()
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            # Extract project name from "projectname is a project" format
            project_name=$(echo "$line" | sed 's/ is a project$//')
            [ -n "$project_name" ] && PROJECTS+=("$project_name")
        fi
    done < "${BUILD_LIST}"
}

# List all projects
list_projects() {
    load_projects
    if [ ${#PROJECTS[@]} -eq 0 ]; then
        log "INFO" "No projects found in build list."
    else
        log "INFO" "Managed Projects:"
        for project in "${PROJECTS[@]}"; do
            echo "  - ${project}"
        done
    fi
}

# Check if project exists in build list
project_exists() {
    local project=$1
    load_projects
    for p in "${PROJECTS[@]}"; do
        if [ "$p" == "$project" ]; then
            return 0
        fi
    done
    return 1
}

# Add a new project
add_project() {
    local project=$1

    if project_exists "$project"; then
        log "WARN" "Project '${project}' is already in the build list."
        return 0
    fi

    echo "${project} is a project" >> "${BUILD_LIST}"
    log "INFO" "Added project '${project}' to build list."
}

# Remove a project
remove_project() {
    local project=$1
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    # Create a temporary file without the project
    grep -v "^${project} is a project$" "${BUILD_LIST}" > "${BUILD_LIST}.tmp"
    mv "${BUILD_LIST}.tmp" "${BUILD_LIST}"
    
    log "INFO" "Removed project '${project}' from build list."
}

# Detect deployment system for a project
detect_deployment_system() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    
    # Priority 1: Custom deployment scripts (they orchestrate TF/Ansible)
    # These scripts typically handle the full deployment pipeline
    local deploy_scripts=(
        "deploy/deploy.sh"            # Most common location
        "deploy/deploy.py"            # Python deployment scripts  
        "deploy.sh"                   # Root level deploy script
        "deploy.py"                   # Root level Python script
        "scripts/deploy/master-deploy.sh"  # Complex projects
        "scripts/deploy/deploy.sh"    # Alternative location
        "bin/deploy.sh"               # Binary/script directory
    )
    
    for script in "${deploy_scripts[@]}"; do
        if [ -x "${project_dir}/${script}" ]; then
            echo "custom:${script}"
            return 0
        fi
    done
    
    # Priority 2: Terraform (usually orchestrates Ansible too)
    if [ -d "${project_dir}/terraform" ]; then
        # Check if Ansible also exists (Terraform often calls Ansible)
        if [ -d "${project_dir}/ansible" ]; then
            echo "standard:terraform=true,ansible=true"
        else
            echo "standard:terraform=true,ansible=false"
        fi
        return 0
    fi
    
    # Priority 3: Standalone Ansible (fallback)
    if [ -d "${project_dir}/ansible" ]; then
        echo "standard:terraform=false,ansible=true"
        return 0
    fi
    
    # Priority 4: No deployment system found
    echo "none"
    return 1
}

# Deploy using custom deployment script
deploy_with_custom_script() {
    local project=$1
    local script_path=$2
    local project_dir="${PROJECTS_DIR}/${project}"
    shift 2  # Remove project and script_path, keep any additional args
    local extra_args="$@"
    
    log "INFO" "Using custom deployment script: ${script_path}"
    
    # Determine how to execute the script
    local script_command
    if [[ "${script_path}" == *.py ]]; then
        script_command="python3 ${script_path}"
        log "INFO" "Detected Python script, using python3"
    else
        script_command="./${script_path}"
    fi
    
    # Build arguments for custom script
    local script_args="--auto-approve"
    if [[ "$extra_args" == *"--plan-only"* ]]; then
        script_args="$script_args --plan-only"
    fi
    if [[ "$extra_args" == *"--verbose"* ]]; then
        script_args="$script_args --verbose"
    fi
    if [[ "$extra_args" == *"--infrastructure-only"* ]]; then
        script_args="$script_args --infrastructure-only"
    fi
    if [[ "$extra_args" == *"--application-only"* ]]; then
        script_args="$script_args --application-only"
    fi
    
    log "INFO" "Running: ${script_command} ${script_args}"
    
    # Change to project directory and run the custom script
    (cd "${project_dir}" && \
     ${script_command} ${script_args}) || {
        log "ERROR" "Custom deployment script failed for ${project}"
        if [[ "${script_path}" == *.py ]]; then
            log "INFO" "You can run the script manually: cd ${project_dir} && python3 ${script_path} --help"
        else
            log "INFO" "You can run the script manually: cd ${project_dir} && ./${script_path} --help"
        fi
        return 1
    }
}

# Deploy using standard terraform/ansible approach
deploy_with_standard_tools() {
    local project=$1
    local deployment_info=$2
    local project_dir="${PROJECTS_DIR}/${project}"
    shift 2  # Remove project and deployment_info, keep extra args
    local extra_args="$@"
    
    # Parse deployment info
    local has_terraform=$(echo "$deployment_info" | grep -o 'terraform=true' > /dev/null && echo true || echo false)
    local has_ansible=$(echo "$deployment_info" | grep -o 'ansible=true' > /dev/null && echo true || echo false)
    
    # Run Terraform
    if [ "$has_terraform" = true ]; then
        if [[ "$extra_args" == *"--plan-only"* ]]; then
            log "INFO" "Running Terraform plan..."
            (cd "${project_dir}/terraform" && \
             terraform init && \
             terraform plan) || {
                log "ERROR" "Terraform plan failed for ${project}"
                return 1
            }
        elif [[ "$extra_args" == *"--application-only"* ]]; then
            log "INFO" "Skipping Terraform (application-only mode)"
        else
            log "INFO" "Running Terraform..."
            (cd "${project_dir}/terraform" && \
             terraform init && \
             terraform apply -auto-approve) || {
                log "ERROR" "Terraform deployment failed for ${project}"
                return 1
            }
        fi
    fi
    
    # Run Ansible
    if [ "$has_ansible" = true ]; then
        if [[ "$extra_args" == *"--plan-only"* ]] || [[ "$extra_args" == *"--infrastructure-only"* ]]; then
            log "INFO" "Skipping Ansible (plan-only or infrastructure-only mode)"
        else
            log "INFO" "Running Ansible..."
            (cd "${project_dir}/ansible" && {
                # Try different playbook configurations
                if [ -f "deploy.yml" ] && [ -f "inventory.yml" ]; then
                    ansible-playbook -i inventory.yml deploy.yml
                elif [ -f "playbook.yml" ] && [ -f "inventory.yml" ]; then
                    ansible-playbook -i inventory.yml playbook.yml
                elif [ -f "site.yml" ] && [ -d "inventory" ]; then
                    ansible-playbook -i inventory/production site.yml
                else
                    log "ERROR" "No suitable ansible configuration found for ${project}"
                    return 1
                fi
            }) || {
                log "ERROR" "Ansible deployment failed for ${project}"
                return 1
            }
        fi
    fi
}

# Deploy a project
deploy_project() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    shift  # Remove project name, keep any additional args
    local extra_args="$@"
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    if [[ "$extra_args" == *"--plan-only"* ]]; then
        log "INFO" "Starting deployment plan for project: ${project}"
    else
        log "INFO" "Starting deployment for project: ${project}"
    fi
    
    # Check if project directory exists
    if [ ! -d "${project_dir}" ]; then
        log "ERROR" "Project directory not found: ${project_dir}"
        return 1
    fi
    
    # Detect deployment system
    local deployment_system=$(detect_deployment_system "$project")
    log "INFO" "Detected deployment system: ${deployment_system}"
    
    case "$deployment_system" in
        custom:*)
            local script_path=${deployment_system#custom:}
            deploy_with_custom_script "$project" "$script_path" $extra_args
            ;;
        standard:*)
            local deployment_info=${deployment_system#standard:}
            deploy_with_standard_tools "$project" "$deployment_info" $extra_args
            ;;
        none)
            log "WARN" "No deployment system detected for ${project}"
            log "INFO" "Looking for common deployment files..."
            
            # List what we found to help the user
            log "INFO" "Project structure:"
            find "${project_dir}" -maxdepth 3 -type f -name "*.sh" -o -name "*.py" -o -name "*.yml" -o -name "*.yaml" -o -name "*.tf" | head -10 | while read -r file; do
                log "INFO" "  Found: ${file#${project_dir}/}"
            done
            
            log "ERROR" "No suitable deployment system found for ${project}"
            log "INFO" "SuperDeploy detection priority:"
            log "INFO" "  1. Custom scripts: deploy/deploy.sh, deploy.py, deploy.sh, etc."
            log "INFO" "  2. Terraform: terraform/ directory (often orchestrates Ansible)"
            log "INFO" "  3. Ansible: ansible/ directory (standalone)"
            log "INFO" "  4. Error: No deployment system found (this case)"
            return 1
            ;;
    esac
    
    if [[ "$extra_args" == *"--plan-only"* ]]; then
        log "INFO" "Successfully completed deployment plan for project: ${project}"
    else
        log "INFO" "Successfully deployed project: ${project}"
    fi
}

# Teardown a project
teardown_project() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    log "WARN" "This will destroy all resources for project: ${project}"
    read -p "Are you sure you want to continue? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "INFO" "Teardown cancelled."
        return 0
    fi
    
    # Run Terraform destroy
    if [ -d "${project_dir}/terraform" ]; then
        log "INFO" "Destroying Terraform resources..."
        (cd "${project_dir}/terraform" && \
         terraform destroy -auto-approve) || {
            log "ERROR" "Terraform teardown failed for ${project}"
            return 1
        }
    fi
    
    log "INFO" "Successfully tore down project: ${project}"
}

# Check project status
check_project() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    log "INFO" "Checking status for project: ${project}"
    
    # Detect deployment system
    local deployment_system=$(detect_deployment_system "$project")
    log "INFO" "Detected deployment system: ${deployment_system}"
    
    case "$deployment_system" in
        custom:*)
            local script_path=${deployment_system#custom:}
            log "INFO" "Project uses custom deployment script: ${script_path}"
            if [ -x "${project_dir}/${script_path}" ]; then
                log "INFO" "Custom script is executable and ready"
                log "INFO" "Run: cd ${project_dir} && ./${script_path} --help for options"
            else
                log "WARN" "Custom script found but not executable"
            fi
            ;;
        standard:*)
            local deployment_info=${deployment_system#standard:}
            local has_terraform=$(echo "$deployment_info" | grep -o 'terraform=true' > /dev/null && echo true || echo false)
            local has_ansible=$(echo "$deployment_info" | grep -o 'ansible=true' > /dev/null && echo true || echo false)
            
            if [ "$has_terraform" = true ]; then
                log "INFO" "Terraform configuration found"
                if [ -f "${project_dir}/terraform/terraform.tfstate" ]; then
                    log "INFO" "Terraform state exists - checking status:"
                    (cd "${project_dir}/terraform" && terraform show --json > /dev/null 2>&1 && echo "  ‚úì Terraform state is valid" || echo "  ‚úó Terraform state may be corrupted")
                else
                    log "INFO" "No Terraform state found - infrastructure may not be deployed"
                fi
            fi
            
            if [ "$has_ansible" = true ]; then
                log "INFO" "Ansible configuration found"
                log "INFO" "Ansible inventory and playbooks are available"
            fi
            ;;
        none)
            log "WARN" "No deployment system detected for ${project}"
            ;;
    esac
    
    log "INFO" "Status check complete for project: ${project}"
}

# Refresh a project
refresh_project() {
    local project=$1
    
    log "INFO" "Refreshing project: ${project}"
    
    # First teardown
    teardown_project "$project" || {
        log "ERROR" "Failed to teardown project during refresh: ${project}"
        return 1
    }
    
    # Then deploy
    deploy_project "$project" || {
        log "ERROR" "Failed to deploy project during refresh: ${project}"
        return 1
    }
    
    log "INFO" "Successfully refreshed project: ${project}"
}

# List available deployment templates
list_templates() {
    log "INFO" "Available deployment templates:"
    
    if [ ! -d "${DEPLOY_TEMPLATES_DIR}" ] || [ -z "$(ls -A "${DEPLOY_TEMPLATES_DIR}" 2>/dev/null)" ]; then
        log "WARN" "No deployment templates found in ${DEPLOY_TEMPLATES_DIR}"
        return 1
    fi
    
    for template_dir in "${DEPLOY_TEMPLATES_DIR}"/*; do
        if [ -d "$template_dir" ]; then
            local template_name=$(basename "$template_dir")
            echo "  üìÅ ${template_name}/"
            
            # List scripts in the template directory
            find "$template_dir" -name "*.sh" -o -name "*.py" -o -name "*.js" | while read -r script; do
                local script_rel=${script#${template_dir}/}
                echo "     üöÄ ${script_rel}"
            done
        fi
    done
    
    # List standalone demo scripts
    for script in "${DEPLOY_TEMPLATES_DIR}"/*.sh "${DEPLOY_TEMPLATES_DIR}"/*.py "${DEPLOY_TEMPLATES_DIR}"/*.js; do
        if [ -f "$script" ]; then
            local script_name=$(basename "$script")
            echo "  üöÄ ${script_name} (standalone demo)"
        fi
    done
}

# Install deployment script from template
install_deploy_script() {
    local project=$1
    local template=$2
    local script_path=$3
    local project_dir="${PROJECTS_DIR}/${project}"
    
    if [ -z "$project" ] || [ -z "$template" ]; then
        log "ERROR" "Usage: install <project> <template> [script-path]"
        log "INFO" "Available templates:"
        list_templates
        return 1
    fi
    
    if [ ! -d "$project_dir" ]; then
        log "ERROR" "Project directory not found: ${project_dir}"
        return 1
    fi
    
    # Check if template exists
    local template_source="${DEPLOY_TEMPLATES_DIR}/${template}"
    
    if [ -d "$template_source" ]; then
        # Template is a directory - copy entire structure
        log "INFO" "Installing deployment template '${template}' for project '${project}'"
        
        # Default script path if not specified
        if [ -z "$script_path" ]; then
            script_path="deploy.sh"
        fi
        
        local target_dir="${project_dir}/$(dirname "$script_path")"
        mkdir -p "$target_dir"
        
        # Copy all files from template directory
        cp -r "$template_source"/* "$target_dir"/
        
        # Make scripts executable
        find "$target_dir" -name "*.sh" -o -name "*.py" -o -name "*.js" | xargs chmod +x
        
        log "SUCCESS" "Deployment template installed to ${target_dir}"
        log "INFO" "Main deployment script: ${project_dir}/${script_path}"
        
    elif [ -f "$template_source" ]; then
        # Template is a single file - copy as deployment script
        log "INFO" "Installing deployment script '${template}' for project '${project}'"
        
        # Default script path based on template extension
        if [ -z "$script_path" ]; then
            local ext="${template##*.}"
            case "$ext" in
                py) script_path="deploy.py" ;;
                js) script_path="deploy.js" ;;
                *) script_path="deploy.sh" ;;
            esac
        fi
        
        local target_file="${project_dir}/${script_path}"
        local target_dir=$(dirname "$target_file")
        
        mkdir -p "$target_dir"
        cp "$template_source" "$target_file"
        chmod +x "$target_file"
        
        log "SUCCESS" "Deployment script installed to ${target_file}"
        
    else
        log "ERROR" "Template '${template}' not found in ${DEPLOY_TEMPLATES_DIR}"
        log "INFO" "Available templates:"
        list_templates
        return 1
    fi
    
    # Update the script with project-specific information
    if [ -f "${project_dir}/${script_path}" ]; then
        log "INFO" "Customizing deployment script for project '${project}'"
        
        # Replace placeholder project names (if any)
        sed -i.bak "s/PROJECT_NAME=\".*\"/PROJECT_NAME=\"${project}\"/g" "${project_dir}/${script_path}" 2>/dev/null || true
        sed -i.bak "s/project_name=.*/project_name=\"${project}\"/g" "${project_dir}/${script_path}" 2>/dev/null || true
        sed -i.bak "s/\"project_name\": \".*\"/\"project_name\": \"${project}\"/g" "${project_dir}/${script_path}" 2>/dev/null || true
        
        # Remove backup file
        rm -f "${project_dir}/${script_path}.bak" 2>/dev/null || true
    fi
    
    log "INFO" "You can now deploy using: $0 deploy ${project}"
    log "INFO" "Or run the script directly: cd ${project_dir} && ./${script_path} --help"
}

# Create a new deployment template
create_template() {
    local template_name=$1
    local template_type=${2:-bash}  # bash, python, javascript
    
    if [ -z "$template_name" ]; then
        log "ERROR" "Usage: create-template <template-name> [type]"
        log "INFO" "Types: bash, python, javascript"
        return 1
    fi
    
    local template_dir="${DEPLOY_TEMPLATES_DIR}/${template_name}"
    
    if [ -d "$template_dir" ]; then
        log "ERROR" "Template '${template_name}' already exists"
        return 1
    fi
    
    mkdir -p "$template_dir"
    
    case "$template_type" in
        python|py)
            log "INFO" "Creating Python deployment template: ${template_name}"
            cp "${DEPLOY_TEMPLATES_DIR}/demo-deploy.py" "${template_dir}/deploy.py"
            chmod +x "${template_dir}/deploy.py"
            ;;
        javascript|js|node)
            log "INFO" "Creating Node.js deployment template: ${template_name}"
            cp "${DEPLOY_TEMPLATES_DIR}/demo-deploy.js" "${template_dir}/deploy.js"
            chmod +x "${template_dir}/deploy.js"
            ;;
        bash|sh|*)
            log "INFO" "Creating Bash deployment template: ${template_name}"
            # Create a basic bash template
            cat > "${template_dir}/deploy.sh" << 'EOF'
#!/bin/bash

# Custom Deployment Script
# Generated by SuperDeploy

set -e

# Configuration
PROJECT_NAME="your-project"
ENVIRONMENT=${1:-prod}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "[${timestamp}] [${level}] ${message}"
}

print_header() {
    echo -e "\n${BLUE}================================${NC}"
    echo -e "${BLUE} $1${NC}"
    echo -e "${BLUE}================================${NC}\n"
}

check_prerequisites() {
    log "INFO" "Checking prerequisites..."
    
    # Add your prerequisite checks here
    command -v docker >/dev/null 2>&1 || { log "ERROR" "Docker is required"; exit 1; }
    command -v aws >/dev/null 2>&1 || { log "ERROR" "AWS CLI is required"; exit 1; }
    
    log "INFO" "Prerequisites check passed"
}

deploy_infrastructure() {
    log "INFO" "Deploying infrastructure..."
    
    # Add your infrastructure deployment logic here
    if [ -d "terraform" ]; then
        cd terraform
        terraform init
        terraform apply -auto-approve
        cd ..
    fi
    
    log "INFO" "Infrastructure deployment completed"
}

deploy_application() {
    log "INFO" "Deploying application..."
    
    # Add your application deployment logic here
    if [ -f "Dockerfile" ]; then
        docker build -t "${PROJECT_NAME}:latest" .
        # Add docker push logic
    fi
    
    log "INFO" "Application deployment completed"
}

main() {
    print_header "Deploying ${PROJECT_NAME}"
    
    check_prerequisites
    deploy_infrastructure
    deploy_application
    
    log "INFO" "Deployment completed successfully!"
}

# Handle command line arguments
case "${1:-deploy}" in
    deploy)
        main
        ;;
    help|--help|-h)
        echo "Usage: $0 [deploy|help]"
        echo "Commands:"
        echo "  deploy    Deploy the application (default)"
        echo "  help      Show this help message"
        ;;
    *)
        echo "Unknown command: $1"
        echo "Run '$0 help' for usage information."
        exit 1
        ;;
esac
EOF
            chmod +x "${template_dir}/deploy.sh"
            ;;
    esac
    
    log "SUCCESS" "Template '${template_name}' created in ${template_dir}"
    log "INFO" "You can now install it with: $0 install <project> ${template_name}"
}

# Main function
main() {
    # Check requirements
    check_requirements
    
    # Parse command line arguments
    local command=$1
    local project=$2
    
    case $command in
        list)
            list_projects
            ;;
        add)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 add <project-name>"
                exit 1
            fi
            add_project "$project"
            ;;
        remove)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 remove <project-name>"
                exit 1
            fi
            remove_project "$project"
            ;;
        deploy)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 deploy <project-name> [options]"
                exit 1
            fi
            # Pass all remaining arguments to deploy_project
            shift 2  # Remove 'deploy' and project name
            deploy_project "$project" "$@"
            ;;
        plan)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 plan <project-name>"
                exit 1
            fi
            # Pass --plan-only to deploy_project
            deploy_project "$project" "--plan-only"
            ;;
        teardown)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 teardown <project-name>"
                exit 1
            fi
            teardown_project "$project"
            ;;
        check)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 check <project-name>"
                exit 1
            fi
            check_project "$project"
            ;;
        refresh)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 refresh <project-name>"
                exit 1
            fi
            refresh_project "$project"
            ;;
        templates|list-templates)
            list_templates
            ;;
        install)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 install <project> <template> [script-path]"
                exit 1
            fi
            local template=$3
            local script_path=$4
            install_deploy_script "$project" "$template" "$script_path"
            ;;
        create-template)
            if [ -z "$project" ]; then
                log "ERROR" "No template name specified. Usage: $0 create-template <template-name> [type]"
                exit 1
            fi
            local template_type=$3
            create_template "$project" "$template_type"
            ;;
        *|help|--help|-h)
            echo "SuperDeploy - Unified Deployment System"
            echo "Usage: $0 <command> [project] [options]"
            echo ""
            echo "Core Commands:"
            echo "  list                        List all managed projects"
            echo "  add <project>               Add a new project"
            echo "  remove <project>            Remove a project"
            echo "  deploy <project> [options]  Deploy a project"
            echo "  plan <project>              Show deployment plan (no changes)"
            echo "  teardown <project>          Tear down a project"
            echo "  check <project>             Check project status"
            echo "  refresh <project>           Rebuild/redeploy a project"
            echo ""
            echo "Template Management:"
            echo "  templates                   List available deployment templates"
            echo "  install <project> <template> [path]  Install deployment script from template"
            echo "  create-template <name> [type]        Create a new deployment template"
            echo ""
            echo "  help                        Show this help message"
            echo ""
            echo "Deployment Options:"
            echo "  --plan-only                 Show plan without making changes"
            echo "  --infrastructure-only       Deploy infrastructure only"
            echo "  --application-only          Deploy application only"
            echo "  --verbose                   Verbose output"
            echo ""
            echo "Template Types (for create-template):"
            echo "  bash, python, javascript    Language for the deployment template"
            echo ""
            echo "Examples:"
            echo "  $0 templates                List available templates"
            echo "  $0 install myproject demo-deploy.py deploy.py"
            echo "  $0 create-template mytemplate python"
            echo "  $0 deploy myproject --plan-only"
            echo ""
            echo "Deployment System Detection Priority:"
            echo "  1. Custom scripts: deploy/deploy.sh, deploy.py, deploy.sh, etc."
            echo "  2. Terraform: terraform/ directory (often orchestrates Ansible)"
            echo "  3. Ansible: ansible/ directory (standalone configuration management)"
            echo "  4. Error: No deployment system found"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
