#!/bin/bash

# SuperDeploy - Unified Deployment System
# Version: 1.0.0

# Configuration
SUPERDEPLOY_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_LIST="${SUPERDEPLOY_HOME}/build.lst"
PROJECTS_DIR="/Users/ryan/development"
LOG_DIR="${SUPERDEPLOY_HOME}/logs"
LOG_FILE="${LOG_DIR}/superdeploy_$(date +%Y%m%d).log"

# Ensure required directories exist
mkdir -p "${LOG_DIR}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "[${timestamp}] [${level}] ${message}" | tee -a "${LOG_FILE}"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check requirements
check_requirements() {
    local missing=()
    
    for cmd in terraform ansible jq; do
        if ! command_exists "$cmd"; then
            missing+=("$cmd")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        log "ERROR" "Missing required commands: ${missing[*]}"
        exit 1
    fi
}

# Load project list
load_projects() {
    if [ ! -f "${BUILD_LIST}" ]; then
        touch "${BUILD_LIST}"
    fi
    PROJECTS=()
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            # Extract project name from "projectname is a project" format
            project_name=$(echo "$line" | sed 's/ is a project$//')
            [ -n "$project_name" ] && PROJECTS+=("$project_name")
        fi
    done < "${BUILD_LIST}"
}

# List all projects
list_projects() {
    load_projects
    if [ ${#PROJECTS[@]} -eq 0 ]; then
        log "INFO" "No projects found in build list."
    else
        log "INFO" "Managed Projects:"
        for project in "${PROJECTS[@]}"; do
            echo "  - ${project}"
        done
    fi
}

# Check if project exists in build list
project_exists() {
    local project=$1
    load_projects
    for p in "${PROJECTS[@]}"; do
        if [ "$p" == "$project" ]; then
            return 0
        fi
    done
    return 1
}

# Add a new project
add_project() {
    local project=$1

    if project_exists "$project"; then
        log "WARN" "Project '${project}' is already in the build list."
        return 0
    fi

    echo "${project} is a project" >> "${BUILD_LIST}"
    log "INFO" "Added project '${project}' to build list."
}

# Remove a project
remove_project() {
    local project=$1
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    # Create a temporary file without the project
    grep -v "^${project} is a project$" "${BUILD_LIST}" > "${BUILD_LIST}.tmp"
    mv "${BUILD_LIST}.tmp" "${BUILD_LIST}"
    
    log "INFO" "Removed project '${project}' from build list."
}

# Detect deployment system for a project
detect_deployment_system() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    
    # Priority 1: Custom deployment scripts (they orchestrate TF/Ansible)
    # These scripts typically handle the full deployment pipeline
    local deploy_scripts=(
        "deploy/deploy.sh"            # Most common location
        "deploy/deploy.py"            # Python deployment scripts  
        "deploy.sh"                   # Root level deploy script
        "deploy.py"                   # Root level Python script
        "scripts/deploy/master-deploy.sh"  # Complex projects
        "scripts/deploy/deploy.sh"    # Alternative location
        "bin/deploy.sh"               # Binary/script directory
    )
    
    for script in "${deploy_scripts[@]}"; do
        if [ -x "${project_dir}/${script}" ]; then
            echo "custom:${script}"
            return 0
        fi
    done
    
    # Priority 2: Terraform (usually orchestrates Ansible too)
    if [ -d "${project_dir}/terraform" ]; then
        # Check if Ansible also exists (Terraform often calls Ansible)
        if [ -d "${project_dir}/ansible" ]; then
            echo "standard:terraform=true,ansible=true"
        else
            echo "standard:terraform=true,ansible=false"
        fi
        return 0
    fi
    
    # Priority 3: Standalone Ansible (fallback)
    if [ -d "${project_dir}/ansible" ]; then
        echo "standard:terraform=false,ansible=true"
        return 0
    fi
    
    # Priority 4: No deployment system found
    echo "none"
    return 1
}

# Deploy using custom deployment script
deploy_with_custom_script() {
    local project=$1
    local script_path=$2
    local project_dir="${PROJECTS_DIR}/${project}"
    shift 2  # Remove project and script_path, keep any additional args
    local extra_args="$@"
    
    log "INFO" "Using custom deployment script: ${script_path}"
    
    # Determine how to execute the script
    local script_command
    if [[ "${script_path}" == *.py ]]; then
        script_command="python3 ${script_path}"
        log "INFO" "Detected Python script, using python3"
    else
        script_command="./${script_path}"
    fi
    
    # Build arguments for custom script
    local script_args="--auto-approve"
    if [[ "$extra_args" == *"--plan-only"* ]]; then
        script_args="$script_args --plan-only"
    fi
    if [[ "$extra_args" == *"--verbose"* ]]; then
        script_args="$script_args --verbose"
    fi
    if [[ "$extra_args" == *"--infrastructure-only"* ]]; then
        script_args="$script_args --infrastructure-only"
    fi
    if [[ "$extra_args" == *"--application-only"* ]]; then
        script_args="$script_args --application-only"
    fi
    
    log "INFO" "Running: ${script_command} ${script_args}"
    
    # Change to project directory and run the custom script
    (cd "${project_dir}" && \
     ${script_command} ${script_args}) || {
        log "ERROR" "Custom deployment script failed for ${project}"
        if [[ "${script_path}" == *.py ]]; then
            log "INFO" "You can run the script manually: cd ${project_dir} && python3 ${script_path} --help"
        else
            log "INFO" "You can run the script manually: cd ${project_dir} && ./${script_path} --help"
        fi
        return 1
    }
}

# Deploy using standard terraform/ansible approach
deploy_with_standard_tools() {
    local project=$1
    local deployment_info=$2
    local project_dir="${PROJECTS_DIR}/${project}"
    shift 2  # Remove project and deployment_info, keep extra args
    local extra_args="$@"
    
    # Parse deployment info
    local has_terraform=$(echo "$deployment_info" | grep -o 'terraform=true' > /dev/null && echo true || echo false)
    local has_ansible=$(echo "$deployment_info" | grep -o 'ansible=true' > /dev/null && echo true || echo false)
    
    # Run Terraform
    if [ "$has_terraform" = true ]; then
        if [[ "$extra_args" == *"--plan-only"* ]]; then
            log "INFO" "Running Terraform plan..."
            (cd "${project_dir}/terraform" && \
             terraform init && \
             terraform plan) || {
                log "ERROR" "Terraform plan failed for ${project}"
                return 1
            }
        elif [[ "$extra_args" == *"--application-only"* ]]; then
            log "INFO" "Skipping Terraform (application-only mode)"
        else
            log "INFO" "Running Terraform..."
            (cd "${project_dir}/terraform" && \
             terraform init && \
             terraform apply -auto-approve) || {
                log "ERROR" "Terraform deployment failed for ${project}"
                return 1
            }
        fi
    fi
    
    # Run Ansible
    if [ "$has_ansible" = true ]; then
        if [[ "$extra_args" == *"--plan-only"* ]] || [[ "$extra_args" == *"--infrastructure-only"* ]]; then
            log "INFO" "Skipping Ansible (plan-only or infrastructure-only mode)"
        else
            log "INFO" "Running Ansible..."
            (cd "${project_dir}/ansible" && {
                # Try different playbook configurations
                if [ -f "deploy.yml" ] && [ -f "inventory.yml" ]; then
                    ansible-playbook -i inventory.yml deploy.yml
                elif [ -f "playbook.yml" ] && [ -f "inventory.yml" ]; then
                    ansible-playbook -i inventory.yml playbook.yml
                elif [ -f "site.yml" ] && [ -d "inventory" ]; then
                    ansible-playbook -i inventory/production site.yml
                else
                    log "ERROR" "No suitable ansible configuration found for ${project}"
                    return 1
                fi
            }) || {
                log "ERROR" "Ansible deployment failed for ${project}"
                return 1
            }
        fi
    fi
}

# Deploy a project
deploy_project() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    shift  # Remove project name, keep any additional args
    local extra_args="$@"
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    if [[ "$extra_args" == *"--plan-only"* ]]; then
        log "INFO" "Starting deployment plan for project: ${project}"
    else
        log "INFO" "Starting deployment for project: ${project}"
    fi
    
    # Check if project directory exists
    if [ ! -d "${project_dir}" ]; then
        log "ERROR" "Project directory not found: ${project_dir}"
        return 1
    fi
    
    # Detect deployment system
    local deployment_system=$(detect_deployment_system "$project")
    log "INFO" "Detected deployment system: ${deployment_system}"
    
    case "$deployment_system" in
        custom:*)
            local script_path=${deployment_system#custom:}
            deploy_with_custom_script "$project" "$script_path" $extra_args
            ;;
        standard:*)
            local deployment_info=${deployment_system#standard:}
            deploy_with_standard_tools "$project" "$deployment_info" $extra_args
            ;;
        none)
            log "WARN" "No deployment system detected for ${project}"
            log "INFO" "Looking for common deployment files..."
            
            # List what we found to help the user
            log "INFO" "Project structure:"
            find "${project_dir}" -maxdepth 3 -type f -name "*.sh" -o -name "*.py" -o -name "*.yml" -o -name "*.yaml" -o -name "*.tf" | head -10 | while read -r file; do
                log "INFO" "  Found: ${file#${project_dir}/}"
            done
            
            log "ERROR" "No suitable deployment system found for ${project}"
            log "INFO" "SuperDeploy detection priority:"
            log "INFO" "  1. Custom scripts: deploy/deploy.sh, deploy.py, deploy.sh, etc."
            log "INFO" "  2. Terraform: terraform/ directory (often orchestrates Ansible)"
            log "INFO" "  3. Ansible: ansible/ directory (standalone)"
            log "INFO" "  4. Error: No deployment system found (this case)"
            return 1
            ;;
    esac
    
    if [[ "$extra_args" == *"--plan-only"* ]]; then
        log "INFO" "Successfully completed deployment plan for project: ${project}"
    else
        log "INFO" "Successfully deployed project: ${project}"
    fi
}

# Teardown a project
teardown_project() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    log "WARN" "This will destroy all resources for project: ${project}"
    read -p "Are you sure you want to continue? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "INFO" "Teardown cancelled."
        return 0
    fi
    
    # Run Terraform destroy
    if [ -d "${project_dir}/terraform" ]; then
        log "INFO" "Destroying Terraform resources..."
        (cd "${project_dir}/terraform" && \
         terraform destroy -auto-approve) || {
            log "ERROR" "Terraform teardown failed for ${project}"
            return 1
        }
    fi
    
    log "INFO" "Successfully tore down project: ${project}"
}

# Check project status
check_project() {
    local project=$1
    local project_dir="${PROJECTS_DIR}/${project}"
    
    if ! project_exists "$project"; then
        log "ERROR" "Project '${project}' not found in build list."
        return 1
    fi
    
    log "INFO" "Checking status for project: ${project}"
    
    # Detect deployment system
    local deployment_system=$(detect_deployment_system "$project")
    log "INFO" "Detected deployment system: ${deployment_system}"
    
    case "$deployment_system" in
        custom:*)
            local script_path=${deployment_system#custom:}
            log "INFO" "Project uses custom deployment script: ${script_path}"
            if [ -x "${project_dir}/${script_path}" ]; then
                log "INFO" "Custom script is executable and ready"
                log "INFO" "Run: cd ${project_dir} && ./${script_path} --help for options"
            else
                log "WARN" "Custom script found but not executable"
            fi
            ;;
        standard:*)
            local deployment_info=${deployment_system#standard:}
            local has_terraform=$(echo "$deployment_info" | grep -o 'terraform=true' > /dev/null && echo true || echo false)
            local has_ansible=$(echo "$deployment_info" | grep -o 'ansible=true' > /dev/null && echo true || echo false)
            
            if [ "$has_terraform" = true ]; then
                log "INFO" "Terraform configuration found"
                if [ -f "${project_dir}/terraform/terraform.tfstate" ]; then
                    log "INFO" "Terraform state exists - checking status:"
                    (cd "${project_dir}/terraform" && terraform show --json > /dev/null 2>&1 && echo "  ✓ Terraform state is valid" || echo "  ✗ Terraform state may be corrupted")
                else
                    log "INFO" "No Terraform state found - infrastructure may not be deployed"
                fi
            fi
            
            if [ "$has_ansible" = true ]; then
                log "INFO" "Ansible configuration found"
                log "INFO" "Ansible inventory and playbooks are available"
            fi
            ;;
        none)
            log "WARN" "No deployment system detected for ${project}"
            ;;
    esac
    
    log "INFO" "Status check complete for project: ${project}"
}

# Refresh a project
refresh_project() {
    local project=$1
    
    log "INFO" "Refreshing project: ${project}"
    
    # First teardown
    teardown_project "$project" || {
        log "ERROR" "Failed to teardown project during refresh: ${project}"
        return 1
    }
    
    # Then deploy
    deploy_project "$project" || {
        log "ERROR" "Failed to deploy project during refresh: ${project}"
        return 1
    }
    
    log "INFO" "Successfully refreshed project: ${project}"
}

# Main function
main() {
    # Check requirements
    check_requirements
    
    # Parse command line arguments
    local command=$1
    local project=$2
    
    case $command in
        list)
            list_projects
            ;;
        add)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 add <project-name>"
                exit 1
            fi
            add_project "$project"
            ;;
        remove)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 remove <project-name>"
                exit 1
            fi
            remove_project "$project"
            ;;
        deploy)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 deploy <project-name> [options]"
                exit 1
            fi
            # Pass all remaining arguments to deploy_project
            shift 2  # Remove 'deploy' and project name
            deploy_project "$project" "$@"
            ;;
        plan)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 plan <project-name>"
                exit 1
            fi
            # Pass --plan-only to deploy_project
            deploy_project "$project" "--plan-only"
            ;;
        teardown)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 teardown <project-name>"
                exit 1
            fi
            teardown_project "$project"
            ;;
        check)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 check <project-name>"
                exit 1
            fi
            check_project "$project"
            ;;
        refresh)
            if [ -z "$project" ]; then
                log "ERROR" "No project specified. Usage: $0 refresh <project-name>"
                exit 1
            fi
            refresh_project "$project"
            ;;
        *|help|--help|-h)
            echo "SuperDeploy - Unified Deployment System"
            echo "Usage: $0 <command> [project] [options]"
            echo ""
            echo "Commands:"
            echo "  list                        List all managed projects"
            echo "  add <project>               Add a new project"
            echo "  remove <project>            Remove a project"
            echo "  deploy <project> [options]  Deploy a project"
            echo "  plan <project>              Show deployment plan (no changes)"
            echo "  teardown <project>          Tear down a project"
            echo "  check <project>             Check project status"
            echo "  refresh <project>           Rebuild/redeploy a project"
            echo "  help                        Show this help message"
            echo ""
            echo "Deployment Options:"
            echo "  --plan-only                 Show plan without making changes"
            echo "  --infrastructure-only       Deploy infrastructure only"
            echo "  --application-only          Deploy application only"
            echo "  --verbose                   Verbose output"
            echo ""
            echo "Deployment System Detection Priority:"
            echo "  1. Custom scripts: deploy/deploy.sh, deploy.py, deploy.sh, etc."
            echo "  2. Terraform: terraform/ directory (often orchestrates Ansible)"
            echo "  3. Ansible: ansible/ directory (standalone configuration management)"
            echo "  4. Error: No deployment system found"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
